---
layout:     post
title:      JAVA后台开发面经整理——Redis部分
subtitle:   秋招待上岸
date:       2019-08-17
author:     Zhaxy
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - JAVA
    - 秋招
    - Redis
    - 面经
---

## 1.为什么用redis，redis常用数据结构及底层实现、redis集群方式（哨兵模式）、redis为什么是单线程的、redis持久化的方式
### 问题一：为什么选择redis？【介绍redis的使用场景与使用redis的原因】
#### 0.1 redis能做的事儿
    (1)排行榜，如果使用传统的关系型数据库来做，非常麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；
    (2)计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
    (3)好友关系，利用集合的一些命令，比如求交集、并集、差集等，可以方便搞定一些共同好友、共同爱好之类的功能；
    (4)简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；
    (5)Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

#### 0.2 redis不能做的事儿
    (1)用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。
    (2)数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。

#### 0.3 使用redis的原因
    【缓存可以用Memcache，Session共享还能用MySql来实现，消息队列可以用RabbitMQ，我们为什么一定要用Redis呢？】
    (1)速度快，完全基于内存，使用C语言实现，网络层使用epoll(非阻塞I/O)解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件。【单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理】
    (2)支持多种数据类型
    (3)功能丰富，可设置键过期，基于发布订阅可实现简单的消息队列，通过Lua脚本创建新命令具有原子性，Pipeline功能减少网络开销。
    (4)采用单线程模型，减少竞争，规避并发问题，不依赖于操作系统类库(redis实现了多路I/O复用)
    (5)支持持久化
    (6)主从复制，高可用/分布式
    (7)支持事务，操作都是原子性的


### 问题二：redis集群方式【主从复制、哨兵、集群】
#### 1.1 主从复制
    在主从复制中，数据库分为俩类，主数据库(master)和从数据库(slave)。其中主从复制有如下特点：
    (1)主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
    (2)从数据库一般都是只读的，并且接收主数据库同步过来的数据
    (3)一个master可以拥有多个slave，但是一个slave只能对应一个master

#### 1.2 主从复制工作机制
    当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照期间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。

#### 1.3主从复制优缺点
    （1）优点：
    1）支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
    2）为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成
    3）Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。
    4）Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
    5）Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据

    （2）缺点：
    1）Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
    2）主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
    3）Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。


#### 2.1 哨兵
    哨兵是redis的高可用性解决方案，哨兵的作用是监控redis系统的运行状况，其功能如下：
    (1)监控主从数据库是否正常运行
    (2)master出现故障时，自动将slave转化为master
    (3)多哨兵配置的时候，哨兵之间也会自动监控
    (4)多个哨兵可以监控同一个redis

#### 2.2 哨兵工作机制
    哨兵进程启动时会读取配置文件的内容，通过sentinel monitor master-name ip port quorum查找到master的ip端口。一个哨兵可以监控多个master数据库，只需要提供多个该配置项即可。同时配置文件还定义了与监控相关的参数，比如master多长时间无响应即即判定位为下线。

    哨兵启动后，会与要监控的master建立俩条异步网络连接：
    (1)一条是订阅连接，用于订阅master的_sentinel_:hello频道与获取其他监控该master的哨兵节点信息
    (2)另一条是命令连接，用于定期(每十秒一次的频率)向master发送INFO等命令，通过接收并分析INFO命令的回复来获取master当前信息(主服务器本身的信息--服务器运行id+服务器角色；属下所有从服务器的信息，哨兵无需提供从服务器的地址信息即可自动发信从服务器)
    
    【为什么有两条连接？】
    (1)在redis目前的发布与订阅功能中，被发送的信息都不会保存在redis服务器中，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息，因此为了不丢失_sentinel_:hello频道的任何信息，必须专门用一个订阅连接来接收该频道的信息。
    (2)除了订阅频道外，哨兵还必须向主服务器发送命令，以此来与主服务器进行通信，所以还必须向主服务器创建命令连接。

    与master建立连接后，哨兵会执行三个操作，这三个操作的发送频率都可以在配置文件中配置：
    (1)定期向master和slave发送INFO命令
    发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。所以说哨兵只需要配置master数据库信息就可以自动发现其slave信息。获取到slave信息后，哨兵也会与slave建立俩条连接执行监控。通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。
    (2)定期向master和slave的_sentinel_:hello频道发送自己的信息
    哨兵向主从数据库的_sentinel_:hello频道发送信息与同样监控这些数据库的哨兵共享自己的信息，发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本。这些信息有以下用处：
       1）其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PING命令。
       2）其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新

    (3)定期向master、slave和其他哨兵发送PING命令
    当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。如果被ping的数据库或者节点超时未回复，哨兵认为其主观下线。如果下线的是master，哨兵会向其他哨兵点发送命令询问他们是否也认为该master主观下线，如果达到一定数目（即配置文件中的quorum）投票，哨兵会认为该master已经客观下线，并选举领头的哨兵节点对主从系统发起故障恢复。

#### 2.3 故障恢复操作
    当主服务器的下线时长超过用户设定的下线时长上限时，哨兵系统会对主服务器执行故障转移操作：
    (1)哨兵系统会挑选主服务器属下的一个从服务器，哨兵向该数据库发送命令将其省纪委主服务器
    (2)哨兵系统会向主服务器属下的所有从服务器发送新的复制指令，让其成为新的主服务器的从服务器，当所有从服务器开始复制到新的主服务器时，故障转移操作执行完毕。
    (3)哨兵系统还会继续监视已下线的主服务器，并在它重新上线时，将它设置为新的主服务器的从服务器。
 
#### 3.1 集群模式
    cluster的出现是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。
    cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。这种模式适合数据量巨大的缓存要求，当数据量不是很大使用sentinel即可。

    redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。

#### 3.2 集群特点
    Redis-Cluster采用无中心结构,它的特点如下：
    (1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
    节点的fail是通过集群中超过半数的节点检测失效时才生效。
    (2)客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

#### 3.3 集群工作方式：
    在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

    为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。

### 问题三：redis为什么是单线程的？    
    (1)Redis将数据储存在内存里面，读写数据的时候都不会受到硬盘I/O速度的限制，所以速度极快。官方表示，由于redis是基于内存的操作，CPU不是redis 的瓶颈，其瓶颈最有可能是及其内存的大小或者网络带宽，既然单线程容易实现，而CPU又不会成为瓶颈，那就顺理成章使用单线程的方案了。这里所谓的单线程，只是在处理我们的网络请求时只有一个线程来处理，一个正式的redis服务器运行的时候肯定不止一个线程，例如redis进行持久化操作时会以子进程或者子线程的方式执行。
    (2)Redis是用”单线程-多路复用IO模型”来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制在进行比较耗时的命令时会使redis的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行

### 问题四：redis数据结构底层存储是如何实现的？
    当我们执行set hello world命令时，会有以下数据模型：dictEntry + redisObject
    (1)dictEntry：Redis给每个key-value键值对分配一个dictEntry，里面有着key和val的指针，next指向下一个dictEntry形成链表，这个指针可以将多个哈希值相同的键值对链接在一起，由此来解决哈希冲突问题(链地址法)。
    (2)sds：键key“hello”是以SDS（简单动态字符串）存储.
    (3)redisObject：值val“world”存储在redisObject中。实际上，redis常用5种类型都是以redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址(ptr指针指向底层实现的数据结构)。redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持。这样设计的好处是，可以针对不同的使用场景，对5中常用类型设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。
    (4)无论是dictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。

### 问题五：redis持久化的方式
#### 4.1 两种持久化方式
    (1)RDB持久化机制，是对redis中的数据执行周期性的持久化。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
    (2)AOF持久化机制，是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录；对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。
    
    通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。

#### 4.2 RDB优缺点
    (1)RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据。
    (2)RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可，极大的避免服务进程执行IO操作。
    (3)相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速。如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据。
    (4)RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

#### 4.3 AOF优缺点
    (1)AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。
    (2)AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。
    (3)AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。
    (4)AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。
    (5)对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。
    (6)AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的。（如果实时写入，那么QPS会大降，redis性能会大大降低）
    (7)以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 OF这种较为复杂的基于命令日志回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。
