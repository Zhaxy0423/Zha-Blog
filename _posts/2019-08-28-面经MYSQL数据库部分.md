---
layout:     post
title:      JAVA后台开发面经整理——MYSQL数据库部分
subtitle:   秋招待上岸
date:       2019-08-22
author:     Zhaxy
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - JAVA
    - 秋招
    - mysql
    - 数据库
    - 面经
---

## 基本sql语句、Mysql性能优化、索引原理（B+树与B树的区别）、索引设计、范式、事务隔离级别、搜索引擎、聚簇索引及最左匹配原则
### 问题一 MYSQL基础相关面试题
#### 1.1 MyISAM和InnoDB区别
    MyISAM是MySQL的默认数据库引擎，虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。MySQL 5.5版本后默认的存储引擎为InnoDB。大多数时候我们使用的都是InnoDB存储引擎，但是在某些情况下使用MyISAM也是合适的(如读密集的情况下)。
    (1)是否支持行级锁：MyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁。
    (2)是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
    (3)是否支持外键：MyISAM不支持，而InnoDB支持。
    (4)是否支持MVCC(多版本并发控制)：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作；MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现；各数据库中MVCC实现并不统一。
多版本并发控制-->通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。

#### 1.2 MyISAM和InnoDB使用的数据结构区别
    MySQL索引使用的数据结构主要有BTree索引和哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。
    (1)MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”。
    (2)InnoDB：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

#### 1.3 查询缓存的使用
    (1)开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。
    (2)缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。
    (3)缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。

#### 1.4 事务的四大特性
    (1)原子性(Atomicity)： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
    (2)一致性(Consistency)：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
    (3)隔离性(Isolation)：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    (4)持久性(Durability)：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 1.5 并发事务带来的问题
    (1)脏读（Dirty read）:当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
    (2)丢失修改（Lost to modify）:指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。【例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。】
    (3)不可重复读（Unrepeatableread）:指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
    (4)幻读（Phantom read）:幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

#### 1.6 事务的隔离级别
    (1)READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
    (2)READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
    (3)REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    (4)SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
MySQL InnoDB存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。与SQL标准不同的地方在于InnoDB存储引擎在REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生，这与其他数据库系统(如SQL Server)是不同的。

#### 1.7 表级锁和行级锁
    (1)表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。
    (2)行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

#### 1.8 数据库大表优化
    MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
    (1)限定数据的范围
       务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；
    (2)读/写分离
       经典的数据库拆分方案，主库负责写，从库负责读；
    (3)垂直分区
       根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 
       (a)垂直拆分的优点：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
       (b)垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。
    (4)水平分区
       保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
       水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。
       需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。

#### 1.9 数据库建表规范
    每个表保存一个实体信息，且具有一个ID字段作为主键。
    (1)第一范式
       关系表中的每列都是原子不可分的项，即每个属性都是最基本的数据项。
    (2)第二范式
       关系表中的所有非主属性都完全依赖于表的每一个候选关键属性，即不能出现部分依赖。
       不满足第二范式出现的问题：
         (a)数据冗余
            对于一门课程，如果有n名学生选修，则这门课程的全部信息将会重复存储n-1次，若一个学生选修了m门课程，则学生全部信息会重复存储m-1次，导致数据冗余存储。
         (b)更新问题
             如果要更新某门课程的学分，那么所有关联这门课程的记录都将更新，否则会出现数据不一致问题。
         (c)插入问题
             假如新增一门课程，但是尚未有学生选修，则该门课程的信息无法入库。
         (d)删除问题
             假如某门课程对应的记录完全被删除，则将导致这门课程的信息完全丢失
    (3)第三范式
       关系表中的所有非主属性由主键直接决定，不存在间接依赖关系(某个字段依赖于主键，而有其他字段依赖于该字段)，简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中包含的非主关键字信息。

### 问题二 数据库索引相关面试题
#### 2.1 为什么要用索引？
    (1)通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
    (2)可以大大加快数据检索速度，减少检索数据量
       没有用索引我们是需要遍历双向链表来定位对应的页，索引底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。
    (3)帮助服务器避免排序和临时表，将随机I/O变为顺序I/O
    (4)可以加速表与表之间的连接

#### 2.2 索引基础知识
    MySql的基本存储结构是页(16KB)，每个数据页可以组成一个双向链表，而每个数据页中的记录又可以组成一个单向链表。每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。以其他列(非主键)作为搜索条件————只能从最小记录开始依次遍历单链表中的每条记录。
【例如】如果我们写select * from user where username='Java3y'，这样没有进行任何优化的sql语句，默认会这样做：定位到记录所在的页，需要遍历双向链表，找到所在的页，从所在的页内中查找相应的记录，由于不是根据主键查询，只能遍历所在页的单链表了。

#### 2.3 索引会降低增删改的速度
    (1)B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会破坏它的原有结构。要维持平衡树，就必须做额外的工作。正因为这些额外的工作开销，导致索引会降低增删改的速度。
    (2)如果我们的主键是自增的，每次插入的ID都会比前面的大，那么我们每次只需要在后面插入就行，不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引

#### 2.4 Hash索引与B+tree索引
    (1)哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。
    【局限性】
       (a)哈希索引也没办法利用索引完成排序
       (b)不支持最左匹配原则
       (c)在有大量重复键值情况下，哈希索引的效率也是极低的---->哈希碰撞问题。
       (d)不支持范围查询

    (2)B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。

    (3)两者区别
       (a)如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
       (b)如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
       (c)哈希索引也没办法利用索引完成排序，以及like ‘xxx%’这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
       (d)哈希索引也不支持多列联合索引的最左匹配规则；
       (e)B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

#### 2.5 聚簇索引/非聚簇索引
    聚集索引就是以主键创建的索引，非聚集索引就是以非主键创建的索引。
    【区别】
       (1)聚集索引在叶子节点存储的是表中的数据
       (2)非聚集索引在叶子节点存储的是主键和索引列
       (3)使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)

#### 2.6 索引最左匹配原则
    由于在B+树结构的索引中，索引项是按照索引定义里面出现的字段顺序排序的，索引在查找的时候，找到第一个满足条件的人之后，直接向右遍历就可以了，由于索引是有序的，所有满足条件的人都会聚集在一起。
    而这种定位到最左边，然后向右遍历寻找，就是我们所说的最左前缀原则。

#### 2.7 索引数据结构相关原理
    一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。
    (1)B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。如果我们采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，所以用B-Tree作为索引结构效率是非常高的。
    (2)B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小，由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。

#### 2.8 联合索引
    它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：第一个字段一定是有序的，当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的。
